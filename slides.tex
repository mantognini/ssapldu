% -*- mode: latex; ispell-local-dictionary: "en_GB" -*-

\documentclass[xcolor={usenames,dvipsnames}]{beamer}
\usepackage[utf8x]{inputenc}

\mode<presentation>
{
  \usetheme{Singapore}
  \usecolortheme{rose}
  %\setbeamercovered{transparent}
  \setbeamercovered{invisible}
  \setbeamercolor*{alerted text}{parent=titlelike}
}
\renewcommand{\emph}[1]{\alert{#1}}


%%% Packages %%%

% Use T1 and a modern font family for better support of accents, etc.
\usepackage[T1]{fontenc}
\usepackage{palatino}  % Palatino

% Language support
\usepackage[english]{babel}

% Support for easily changing the enumerator in
% enumerate-environments.
\usepackage{enumerate}

% Support for importing images
%\usepackage{graphicx}

% Use hyperlinks
\usepackage{hyperref}

% Don't load xcolors package in beamer: use document class option
% instead...
%\usepackage[usenames,dvipsnames]{xcolor}

% Use colors in tables
%\usepackage[pdftex]{colortbl}

% My personal list of commonly used math packages and macros
\usepackage{mathcommon}

% More math symbols (e.g. double-brackets: \llbracket, \rrbracket)
\usepackage{stmaryrd}

% A nice monospace font for listings, etc.
\usepackage[scaled]{beramono}
%\usepackage{inconsolata}

\colorlet{Insertion}{NavyBlue}
\colorlet{Modification}{ForestGreen}
\colorlet{VariableEdge}{Cyan}
\colorlet{SelectorEdge}{Plum}
\colorlet{LightGrey}{gray!40}


% Scala listings.  Use colored Scala style by default.
\usepackage{lstscala}
\lstset{
  style=scala-color,
  basicstyle=\footnotesize\tt,
  otherkeywords={do,od},
  moredelim=**[is][\color{Insertion}]{@}{@},
  moredelim=**[is][\color{Modification}]{>}{<}}
\lstnewenvironment{lstscalasmall}{%
  \lstset{style=scala-color,basicstyle=\scriptsize\tt}}{}

% Algorithms/pseud-ocode typesetting
%\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
%\usepackage[slide,vlined,linesnumbered]{algorithm2e}
%\usepackage{float}

% Using TikZ for diagrams
\usepackage{tikz}
\usetikzlibrary{arrows,fit,matrix,positioning}
\usepackage{tikz-cd} % for CM-arrow tips.

% Don't use externalize with gradients!!!
%\usetikzlibrary{external,arrows,fit,matrix,positioning}
%\tikzexternalize % Activate externalizing TikZ graphics.

% Support per-slide PGF/TikZ keys (http://tex.stackexchange.com/a/6155)
\tikzset{onslide/.code args={<#1>#2}{%
  \only<#1>{\pgfkeysalso{#2}} % \pgfkeysalso doesn't change the path
}}

\newcommand{\TODO}[1]{\texttt{\textcolor{YellowOrange}{(#1)}}}

\newcommand\defeq{\stackrel{\mathclap{\tiny\mbox{def}}}{=}}

\newcommand{\transformer}[2]{$\llbracket$ \lstinline@#1@ $\rrbracket_{#2}$}
\newcommand{\transformerDSG}[1]{\transformer{#1}{DSG}}
\newcommand{\mtransformer}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\mtransformerDSG}[1]{\mtransformer{#1}{DSG}}

%%%% Custom macros %%%%
\newif\ifcompileTreeSlides
%\compileTreeSlidesfalse
\compileTreeSlidestrue

%%% Document info %%%

\title{Solving Shape-Analysis Problems in Languages with Destructive Updating}

\subtitle{SAV Presentation}

\author[Sagiv~et~al.]{%
  {\small Authors}\\ \vspace{1ex}
  Shmuel Sagiv, Thomas W. Reps, Reinhard Wilhelm \\
  \vspace{1em}
  {\small Presenters}\\ \vspace{1ex}
  Marco Antognini, Sandro Stucki
}

% \institute[LAMP, Oracle]{%
%   \inst{1} LAMP, EPFL \and%
%   \inst{2} Oracle Labs}

% Logos
% \logo{
%   \includegraphics[height=7mm]{somelogo.png}\hspace{1mm}
%   \includegraphics[height=7mm]{someotherlogo}
% }

% To show the TOC at the beginning of each section, uncomment this:
% \AtBeginSection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection]
%   \end{frame}
% }

% To show the TOC at the beginning of each subsection, uncomment this:
% \AtBeginSubsection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }


% To uncover everything in a step-wise fashion, uncomment this:
% \beamerdefaultoverlayspecification{<+->}

\setbeamertemplate{footline}[frame number]

\date{%
  \vspace{-1em}
  \small May 2015\\[2em]
  \includegraphics[height=7mm]{img/epfl-logo}}


%%% Start of the actual document %%%

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Short-cut for inline listings using "@" (must come after "\titlepage")
\lstMakeShortInline[%
  style=scala-color,%
  flexiblecolumns=false,%
  mathescape=false,%
  basicstyle=\color{blue!30!darkgray}\tt]@


% No outline, too short a talk...
% \begin{frame}{Outline}
%   \tableofcontents
%   % You might wish to add the option [pausesections]
% \end{frame}

% No sections or subsections, too short a talk...
% \section{Motivation}
% \subsection*{}

\begin{frame}[fragile]{Motivation}
  Analyse the shape of heap allocated data structures.

  \vspace{1em}

  Verify that a program preserves shape properties such as:
  \begin{itemize}
  \item \textit{list-ness}
  \item \textit{circular list-ness}
  \item \textit{tree-ness}
  \end{itemize}

  \vspace{1em}

  This analysis algorithm can be used to find \emph{aliases}, and therefore to optimise code (no alias means it can be more easily parallelised).
\end{frame}

\begin{frame}[fragile]{List Reversal: Normalisation}
  \begin{columns}[T]
	  \column{.5\textwidth}
	  \begin{onlyenv}<1>
	  \begin{lstlisting}[mathescape=true]
	  // x points to an unshared list
	  y := nil
	  while x $ \neq $ nil do

	    t := y

	    y := x



	    x := x.cdr

	    y.cdr := t
	  od

	  t := nil
	  \end{lstlisting}
	  \end{onlyenv}
	  \begin{onlyenv}<2>
	  \begin{lstlisting}[mathescape=true]
	  // x points to an unshared list
	  y := nil
	  while x $ \neq $ nil do
	    @t := nil@
	    t := y
	    @y := nil@
	    y := x
	    @t$\color{Insertion}_1$ := nil@
	    @t$\color{Insertion}_1$ := x.cdr@
	    @x := nil@
	    >x := t$\color{Modification}_1$<
	    @y.cdr := nil@
	    y.cdr := t
	  od
	  @t$\color{Insertion}_1$ := nil@
	  t := nil
	  \end{lstlisting}
        \end{onlyenv}
        \column{.5\textwidth}
        \pause
	\TODO{Fig 1. (c)}
  \end{columns}
\end{frame}


%%%% The following is a crazy TikZ slide combining tree/graph drawing
%%%% code, etc.

\newcommand{\celldraw}[1]{#1!80!black!80!white}%
\newcommand{\cellfill}[1]{#1!80!black!30!white}%

% Basic style of a cell box.
\tikzstyle{cellbox}=[rectangle, thick, draw=\celldraw{#1}, top color=white,%
  bottom color=\cellfill{#1}, minimum width=2em, minimum height=1em,
  inner sep=0]

% The matrix style underlying graphs.
\tikzstyle{graph}=[matrix, row sep=1pt, column sep=.5em, node distance=0pt,%
  nodes={anchor=center}]

% Basic style for variable labels.
\tikzstyle{labelnode}=[font=\tiny, node distance=.6em, inner sep=1pt]

% Style for transformer arrow tips.
\tikzstyle{trans}=[-cm to]

% Basic cell.  The first argument is the name of the node (in TeX,
% e.g. "xy"), the second one is its printed name (e.g. "n_{x, y}").
% The third argument determines the color.  The optional argument
% contains extra node parameters (e.g. minimum width=1em creates cell
% that is less wide).
\newcommand{\cell}[4][]{%
  \node[rectangle, cellbox=#4, #1] (#2) {};% (#2-car)
  \draw[draw=\celldraw{#4}, semithick] (#2.north) -- (#2.south);
  \path (#2.west) -- coordinate[midway] (#2-car) (#2.center);%
  \path (#2.east) -- coordinate[midway] (#2-cdr) (#2.center);%
  \node[font=\tiny, below=of #2.south west, anchor=north west, inner sep=1pt]
  {$#3$};}%

% A basic cons cell with a circle in the "cdr" box.  Arguments are the
% same as for \cell.
\newcommand{\cons}[4][]{%
  \cell[#1]{#2}{#3}{#4}%
  \node[circle, fill=black, inner sep=.75pt] at (#2-cdr) {};}%

% A concrete (green) cons cell.
\newcommand{\ccons}[3][]{\cons[#1]{#2}{#3}{green}}

% An abstract (blue) cons cell.
\newcommand{\acons}[3][]{\cons[#1]{#2}{n_{#3}}{blue}}

% A shared (red) cons cell.
\newcommand{\scons}[3][]{\cons[#1]{#2}{n_{#3}}{red}}

% Variable label and edge. Arguments are position, node and label text.
\newcommand{\vlabel}[3]{%
  \node[labelnode, #1=of #2] {$#3$} edge (#2);}%

% example: \vlabelwy{xy}{x}{1mm}
\newcommand{\vlabelwy}[3]{%
  \node[labelnode, yshift=#3, left=of #1] {$#2$} edge ([yshift=#3]#1.west);}%

% Draws a "transformer" arrow.
\newcommand{\transarrow}[3]{%
  \draw[trans] ($(#1.east)+(1em,0)$) -- node[above]{\normalsize #2}
  ($(#3.west)+(-1em,0)$);}

\ifcompileTreeSlides



\begin{frame}[fragile]{Shape-Graph $SG = \langle E_v, E_s \rangle$}

	%\emph{Not} to be confused by a program control flow graph $G = (V, A)$
	%\vspace{1em}
	
	What is a \textbf{shape-graph}?

	\begin{itemize}
	\item directed graph with nodes and edges
	\item nodes are called \textcolor{Green}{\textbf{shape-nodes}}
		\begin{itemize}
		\item[$\circ$] runtime locations, i.e. heap memory, or \textit{cons-cells}
		\item[$\circ$] implicitly defined by edges and $shape\_nodes(SG)$
		\end{itemize}
	\item edges are divided into 2 categories:
		\begin{itemize}
    	\item[$\circ$] \textcolor{VariableEdge}{$E_v$: \textbf{variable-edges}} of the form $ \left[x, n\right] $
    	\item[$\circ$] \textcolor{SelectorEdge}{$E_s$: \textbf{selector-edges}} of the form $ \langle s, sel, t \rangle $
		\end{itemize}
	\end{itemize}

	\begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      % Matrix for arranging graph nodes.  You can set the overall
      % spacing through "row sep" and "column sep" or add and remove
      % horizontal or vertical space in brackets after \& and \\.
      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge[SelectorEdge] (l2)
      (l2-cdr) edge[SelectorEdge] (l3);

      % Variable egdes.
      %\vlabel{left}{l1}{x} % need color on edge:
      \node[labelnode, left=of l1] {$x$} edge[VariableEdge] (l1);
    \end{tikzpicture}
  \end{center}

	%$n, s, t, l_1, l_2$ and $l_3$ are shape-nodes, $x$ a program variable and $sel \in \left\{ car, cdr \right\}$

\end{frame}

\begin{frame}[fragile]{$DSG$: Deterministic Shape-Graph}
  $E_v$ and $E_s$ are also used as functions:
  \begin{itemize}
  \item $E_v(x) \defeq \left\{ n \mid \left[x, n\right] \in E_v \right\}$
  \item $E_s(s, sel) \defeq \left\{ t \mid \langle s, sel, t \rangle \in E_s \right\}$
  \end{itemize}
  \TODO{is this notation used anywhere else in the slides? O/w inline
    below?}

  \vspace{1em}

  A shape-graph is \textbf{deterministic} if
  \begin{enumerate}
  \item no variable points to more than one node: $ |E_v(*)| \leq 1$
  \item no node has a selector pointing to more than one node: $ |E_s(*, *)| \leq 1$
  \end{enumerate}
\end{frame}


\begin{frame}[fragile]{$gc$: Garbage Collection}
  The $gc$ function removes runtime location that are not reachable from any program variable:

  \vspace{1em}

  $ gc: SG \to SG $\\
  $ gc\left(\langle E_v, E_s \rangle \right) \defeq \langle E_v, E'_s \rangle $ where $ E'_s \subseteq E_s $ and $ \langle s, sel, t \rangle \in E'_s $ if and only if there exists $ \left[ x, r \right] \in E_v $ such that there is a path of selector-edges in $ E_s $ from $r$ to $s$.

	\begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      // Initial graph
      \matrix[graph, column sep=1em] (lhs) at (-8em, 0)
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \\
        \ccons[minimum width=1em]{l3}{l_3} \&
        \ccons[minimum width=1em]{l4}{l_4} \&
        \ccons[minimum width=1em]{l5}{l_5} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l5)
      (l3-cdr) edge (l4)
      (l4-cdr) edge (l5);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      
      % After applying gc
      \matrix[graph, column sep=1em] (rhs) at (7em, 0)
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \\
        \& \&
        \ccons[minimum width=1em]{l5}{l_5} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l5);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      
      % Transformer arrow
      \transarrow{lhs}{$gc$}{rhs}
    \end{tikzpicture}
  \end{center}
\end{frame}


\begin{frame}[fragile]{$DSG$ transformers}
  A program statement is represented as a transform function on $DSG$, denoted \transformerDSG{st}.

  \vspace{1em}

  Thanks to program normalisation, there are only 6 statements and they are simple:

  \begin{enumerate}
  \item \transformerDSG{x := nil}
  \item \transformerDSG{x.sel := nil}
  \item \transformerDSG{x := new}
  \item \transformerDSG{x := y}
  \item \transformerDSG{x := y.sel}
  \item \transformerDSG{x.sel := y}
  \end{enumerate}
\end{frame}


\begin{frame}[fragile]{$DSG$ transformers: 1}
  \transformerDSG{x := nil}$ \left( \langle E_v, E_s \rangle \right) $ \\
  \hspace{5em} $ \defeq \langle E_v - \left\{\left[ \mbox{x}, * \right]\right\}, E_s \rangle $

  \vspace{1em}

  Let $ \langle E_v, E_s \rangle $ be\\
  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}

  \transformerDSG{x := nil} results in, after $gc$:

%  \begin{center}
%    \begin{tikzpicture}[semithick,
%      ampersand replacement=\&, every edge/.append style={->}, >=latex]
%      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...
%
%      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
%      {
%        \ccons[minimum width=1em]{l1}{l_1} \&
%        \ccons[minimum width=1em]{l2}{l_2} \&
%        \ccons[minimum width=1em]{l3}{l_3} \\
%      };
%
%      % Selector edges.
%      \path[->]
%      (l1-cdr) edge (l2)
%      (l2-cdr) edge (l3);
%
%      % Variable egdes.
%      \vlabel{above}{l2}{y}
%    \end{tikzpicture}
%  \end{center}
%
%  and after $gc$:

  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \& \&                              \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]{$DSG$ transformers: 1 (simplified)}
  \[
  \text{\transformerDSG{x := nil}} \left( \langle E_v, E_s \rangle
  \right) \quad \defeq \quad \langle E_v - \left\{\left[ \mbox{x}, *
    \right]\right\}, E_s \rangle
  \]

  \vspace{1em}

  \begin{center}
    \begin{tikzpicture}[semithick, ampersand replacement=\&,%
      every edge/.append style={->}, >=latex]
      \Large

      \matrix[graph, column sep=1em] (lhs) at (-8em, 0)
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}

      \matrix[graph, column sep=1em] (rhs) at (7em, 0)
      {
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{above}{l2}{y}

      % Transformer arrow
      \transarrow{lhs}{$gc \comp$\transformerDSG{x := nil}}{rhs}
    \end{tikzpicture}
  \end{center}

  \vspace{1em}

  (NB: here, $\mtransformerDSG{-}$ is followed by a call to $gc$).
  \TODO{The $gc$ thing might be confusing. Remove and explain during
    the talk?}
\end{frame}


\begin{frame}[fragile]{$DSG$ transformers: 2}
  \transformerDSG{x.sel := nil}$ \left( \langle E_v, E_s \rangle \right) $ \\
  \hspace{5em} $ \defeq \langle E_v, E_s - \left\{ \langle \mbox{s}, \mbox{sel}, * \rangle \mid \left[x,s\right] \in E_v \right\} \rangle $

  \vspace{1em}

  Let $ \langle E_v, E_s \rangle $ be\\
  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}

  \transformerDSG{y.cdr := nil} results in, after $gc$:

  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \&                                 \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}
\end{frame}



\begin{frame}[fragile]{$DSG$ transformers: 3}
  \transformerDSG{x := new}$ \left( \langle E_v, E_s \rangle \right) $ \\
  \hspace{5em} $ \defeq \langle E_v \cup \left\{ \left[ \mbox{x}, \mbox{n}_{new} \right] \right\}, E_s \rangle $

  \vspace{1em}

  Let $ \langle E_v, E_s \rangle $ be\\
  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \&
        \& \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}

  \transformerDSG{z := new} results in\textcolor{LightGrey}{, after $gc$}:

  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \&
        \ccons[minimum width=1em]{l4}{l_4} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
      \vlabel{above}{l4}{z}
    \end{tikzpicture}
  \end{center}

  No garbage collection because z is known to be nil right before this statement thanks to normalisation.
\end{frame}



\begin{frame}[fragile]{$DSG$ transformers: 4}
  \transformerDSG{x := y}$ \left( \langle E_v, E_s \rangle \right) $ \\
  \hspace{5em} $ \defeq \langle E_v \cup \left\{ \left[ \mbox{x}, \mbox{n} \right] \mid \left[ \mbox{y}, \mbox{n} \right] \in E_v \right\}, E_s \rangle $

  \vspace{1em}

  Let $ \langle E_v, E_s \rangle $ be\\
  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}

  \transformerDSG{z := x} results in\textcolor{LightGrey}{, after $gc$}:

  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l1}{z}
%      \node[labelnode, yshift=1mm, left=of l1] {$z$} edge ([yshift=1mm]l1.west);
%      \node[labelnode, yshift=-1mm, left=of l1] {$x$} edge ([yshift=-1mm]l1.west);
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}

  No garbage collection because z is known to be nil right before this statement thanks to normalisation.
\end{frame}



\begin{frame}[fragile]{$DSG$ transformers: 5}
  \transformerDSG{x := y.sel}$ \left( \langle E_v, E_s \rangle \right) $ \\
  \hspace{5em} $ \defeq \langle E_v \cup \left\{ \left[ \mbox{x}, \mbox{t} \right] \mid \left[ \mbox{y}, \mbox{s} \right] \in E_v \wedge \langle \mbox{s}, \mbox{sel}, \mbox{t} \rangle \in E_s \right\}, E_s \rangle $

  \vspace{1em}

  Let $ \langle E_v, E_s \rangle $ be\\
  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
    \end{tikzpicture}
  \end{center}

  \transformerDSG{z := y.cdr} results in\textcolor{LightGrey}{, after $gc$}:

  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
      \vlabel{above}{l3}{z}
    \end{tikzpicture}
  \end{center}

  No garbage collection because z is known to be nil right before this statement thanks to normalisation.
\end{frame}



\begin{frame}[fragile]{$DSG$ transformers: 6}
  \transformerDSG{x.sel := y}$ \left( \langle E_v, E_s \rangle \right) $ \\
  \hspace{5em} $ \defeq \langle E_v, E_s \cup \left\{ \langle \mbox{s}, \mbox{sel}, \mbox{t} \rangle \mid \left[ \mbox{x}, \mbox{s} \right] \in E_v \wedge \left[ \mbox{y}, \mbox{t} \right] \in E_v \right\} \rangle $

  \vspace{1em}

  Let $ \langle E_v, E_s \rangle $ be\\
  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
      \vlabel{above}{l3}{z}
    \end{tikzpicture}
  \end{center}

  \transformerDSG{y.cdr := z} results in\textcolor{LightGrey}{, after $gc$}:

  \begin{center}
    \begin{tikzpicture}[semithick,
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...

      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}
      \vlabel{above}{l2}{y}
      \vlabel{above}{l3}{z}
    \end{tikzpicture}
  \end{center}

  No garbage collection because y.cdr is known to be nil right before this statement thanks to normalisation.
\end{frame}

\begin{frame}[fragile]{Collecting Semantics}
  Each DSG models one runtime behaviour (of many).

  \vspace{1em}

  We need a tool to perform analysis on \textbf{all} possible execution paths, not just one.

  \vspace{2em}

  Hence the collecting function $cv: V \to 2^{DSG}$ \\
  $cv(v) \defeq \{ $ \transformerDSG{st($v_k$)} $ ( \cdots ( $ \transformerDSG{st($v_1$)} $ ( \langle \emptyset, \emptyset \rangle ))) \mid $ \\
  \hspace{16em} $ \left[ v_1, \ldots, v_k \right] \in pathsTo(v) \} $

  \vspace{2em}

  $V$ is the vertex set of the \textit{regular} control flow graph $G = (V, A)$.
\end{frame}



% TODO insert more slides here



\begin{frame}[fragile]{Sharing}
  \only<1>{

  From $v_1$ to $v_{11}$ \textit{without entering} the loop. \\
  Executing \transformer{e.cdr := nil}{} -- $n_{\{t\}}$ is \textbf{not} shared.
  \vspace{1.5em} % TODO need better alignment (vertical & horizontal)
  \begin{center}
    \begin{tikzpicture}[semithick,
%      level 1/.style={onslide=<-0>{transparent}},
%      level 2/.style={onslide=<-1>{transparent}},
%      level 3/.style={onslide=<-2>{transparent}},
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large

      % Fig. 8/9, at vertex v11 (before) when loop not executed:
%      \begin{scope}[level 1]
	      \matrix[graph, column sep=1em] (g1)
	      {
	         \&\&            \&                      \& \acons{t}{\{t\}} \& \acons{phi}{\emptyset} \\
	         \&\&            \& \acons{xy}{\{x, y\}} \& \acons{e}{\{e\}} \&                        \\
	      };

	      % Selector edges.
	      \path[->]
	      (t-cdr) edge (phi)
	      (xy-cdr) edge (t);
	      % loop for phi
	      \draw[->] (phi-cdr) -| ++(1em, 1em) -| (phi.north);

	      % Variable egdes.
	      \vlabelwy{xy}{x}{1.5mm}
	      \vlabelwy{xy}{y}{-1.5mm}
	      \vlabelwy{t}{t}{1.5mm}
	      \vlabelwy{e}{e}{0mm}
%      \end{scope}
    \end{tikzpicture}
  \end{center}
  }

  \only<2>{

  From $v_1$ to $v_{11}$ \textit{through} the loop. \\
  Executing \transformer{e.cdr := nil}{} -- $n_{\{t\}}$ is \textbf{not} shared.

  \begin{center}
    \begin{tikzpicture}[semithick,
%      level 1/.style={onslide=<-0>{transparent}},
%      level 2/.style={onslide=<-1>{transparent}},
%      level 3/.style={onslide=<-2>{transparent}},
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large

      % Fig. 8/9, at vertex v11 (before) when loop is executed:
%      \begin{scope}[level 1]
	      \matrix[graph, column sep=1em] (g1)
	      {
	        \acons{x}{\{x\}} \& \acons{yz}{\{y, z\}} \& \acons{t}{\{t\}} \& \acons{phi}{\emptyset} \\
	                         \&                      \& \acons{e}{\{e\}} \&                        \\
	      };


	      % Selector edges.
	      \path[->]
	      (t-cdr) edge (phi)
	      (x-cdr) edge (yz)
	      (yz-cdr) edge (t);
	      % loops
	      \draw[->] (x-cdr) -| ++(0, 2em) -| ([xshift=-1ex]phi.north);
	      \draw[->] (phi-cdr) -| ++(1em, 1em) -| (phi.north);
	      \draw[->] (phi-cdr) -| ++(0, 1.5em) -| (yz.north);
	      \draw[->] (t-cdr) -| ++(0, 1em) -| ([xshift=1ex]yz.north);

	      % Variable egdes.
	      \vlabelwy{x}{x}{0mm}
	      \vlabelwy{yz}{y}{1.5mm}
	      \vlabelwy{yz}{z}{-1.5mm}
	      \vlabelwy{t}{t}{1.5mm}
	      \vlabelwy{e}{e}{0mm}
%      \end{scope}
    \end{tikzpicture}
  \end{center}
  }

  \only<3>{

  From $v_1$ to $v_{11}$ by all possible paths. \\
  Executing \transformer{e.cdr := nil}{} -- $n_{\{t\}}$ is still \textbf{not} shared.

  \begin{center}
    \begin{tikzpicture}[semithick,
%      level 1/.style={onslide=<-0>{transparent}},
%      level 2/.style={onslide=<-1>{transparent}},
%      level 3/.style={onslide=<-2>{transparent}},
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large

      % Fig. 8/9, at vertex v11 (before) for all paths:
%      \begin{scope}[level 1]
	      \matrix[graph, column sep=1em] (g1)
	      {
	        \acons{x}{\{x\}} \& \acons{yz}{\{y, z\}} \& \acons{t}{\{t\}} \& \acons{phi}{\emptyset} \\
	                         \& \acons{xy}{\{x, y\}} \& \acons{e}{\{e\}} \&                        \\
	      };


	      % Selector edges.
	      \path[->]
	      (t-cdr) edge (phi)
	      (x-cdr) edge (yz)
	      (xy-cdr) edge (t)
	      (yz-cdr) edge (t);
	      % loops
	      \draw[->] (x-cdr) -| ++(0, 2em) -| ([xshift=-1ex]phi.north);
	      \draw[->] (phi-cdr) -| ++(1em, 1em) -| (phi.north);
	      \draw[->] (phi-cdr) -| ++(0, 1.5em) -| (yz.north);
	      \draw[->] (t-cdr) -| ++(0, 1em) -| ([xshift=1ex]yz.north);

	      % Variable egdes.
	      \vlabelwy{x}{x}{0mm}
	      \vlabelwy{xy}{x}{1.5mm}
	      \vlabelwy{xy}{y}{-1.5mm}
	      \vlabelwy{yz}{y}{1.5mm}
	      \vlabelwy{yz}{z}{-1.5mm}
	      \vlabelwy{t}{t}{1.5mm}
	      \vlabelwy{e}{e}{0mm}
%      \end{scope}
    \end{tikzpicture}
  \end{center}
  }

  \only<4>{

  From $v_1$ to $v_{12}$ by all possible paths. \\
  Executing \transformer{e.cdr := t}{} -- $n_{\{t\}}$ \textbf{is} shared.

  \begin{center}
    \begin{tikzpicture}[semithick,
%      level 1/.style={onslide=<-0>{transparent}},
%      level 2/.style={onslide=<-1>{transparent}},
%      level 3/.style={onslide=<-2>{transparent}},
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large

      % Fig. 8/9, at vertex v12 (before) for all paths:
%      \begin{scope}[level 1]
	      \matrix[graph, column sep=1em] (g1)
	      {
	        \acons{x}{\{x\}} \& \acons{yz}{\{y, z\}} \& \scons{t}{\{t\}} \& \acons{phi}{\emptyset} \\
	                         \& \acons{xy}{\{x, y\}} \& \acons{e}{\{e\}} \&                        \\
	      };


	      % Selector edges.
	      \path[->]
	      (t-cdr) edge (phi)
	      (x-cdr) edge (yz)
	      (xy-cdr) edge (t)
	      (yz-cdr) edge (t)
	      (e-cdr) edge[RubineRed] ([xshift=1ex]t.south);
	      % loops
	      \draw[->] (x-cdr) -| ++(0, 2em) -| ([xshift=-1ex]phi.north);
	      \draw[->] (phi-cdr) -| ++(1em, 1em) -| (phi.north);
	      \draw[->] (phi-cdr) -| ++(0, 1.5em) -| (yz.north);
	      \draw[->] (t-cdr) -| ++(0, 1em) -| ([xshift=1ex]yz.north);

	      % Variable egdes.
	      \vlabelwy{x}{x}{0mm}
	      \vlabelwy{xy}{x}{1.5mm}
	      \vlabelwy{xy}{y}{-1.5mm}
	      \vlabelwy{yz}{y}{1.5mm}
	      \vlabelwy{yz}{z}{-1.5mm}
	      \vlabelwy{t}{t}{1.5mm}
	      \vlabelwy{e}{e}{0mm}
%      \end{scope}
    \end{tikzpicture}
  \end{center}
  }

  \only<5>{

  From $v_1$ to $v_{13}$ by all possible paths. \\
  Executing \transformer{y.cdr := nil}{} -- \textbf{strong nullification}.

  \begin{center}
    \begin{tikzpicture}[semithick,
%      level 1/.style={onslide=<-0>{transparent}},
%      level 2/.style={onslide=<-1>{transparent}},
%      level 3/.style={onslide=<-2>{transparent}},
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large

      % Fig. 8/9, at vertex v13 (before) for all paths:
%      \begin{scope}[level 1]
	      \matrix[graph, column sep=1em] (g1)
	      {
	        \acons{x}{\{x\}} \& \acons{yz}{\{y, z\}} \& \acons{t}{\{t\}} \& \acons{phi}{\emptyset} \\
	                         \& \acons{xy}{\{x, y\}} \& \acons{e}{\{e\}} \&                        \\
	      };


	      % Selector edges.
	      \path[->]
	      (t-cdr) edge (phi)
	      (x-cdr) edge (yz)
	      (xy-cdr) edge[LightGrey] (t)
	      (yz-cdr) edge[LightGrey] (t)
	      (e-cdr) edge ([xshift=1ex]t.south);
	      % loops
	      \draw[->] (x-cdr) -| ++(0, 2em) -| ([xshift=-1ex]phi.north);
	      \draw[->] (phi-cdr) -| ++(1em, 1em) -| (phi.north);
	      \draw[->] (phi-cdr) -| ++(0, 1.5em) -| (yz.north);
	      \draw[->] (t-cdr) -| ++(0, 1em) -| ([xshift=1ex]yz.north);

	      % Variable egdes.
	      \vlabelwy{x}{x}{0mm}
	      \vlabelwy{xy}{x}{1.5mm}
	      \vlabelwy{xy}{y}{-1.5mm}
	      \vlabelwy{yz}{y}{1.5mm}
	      \vlabelwy{yz}{z}{-1.5mm}
	      \vlabelwy{t}{t}{1.5mm}
	      \vlabelwy{e}{e}{0mm}
%      \end{scope}
    \end{tikzpicture}
  \end{center}
  }
\end{frame}

\begin{frame}[fragile]{Extensions}
  \begin{description}
  \item[Merging Shape-Nodes] to avoid a huge number of nodes ($\leq 2^{|PVar|}$), a widening operator can be introduced.
  \item[Finding Aliases and Sharing] testing whether $x$ and $y$ are aliases at some point of the program can be extended to test whether two paths can alias by introducing two extra variables.
  \item[Interprocedural Analysis] \textit{shape-graph-transformations} can be introduced to accurately model procedures.
  \item[Representing Definitely Circular Structures] with extra special nodes ($n_{atom}, n_{nil}, n_{uninit}$), definitely cyclic data structures can be modelled.
  \end{description}
\end{frame}


\begin{frame}[fragile,t]{Graph example}
  \vspace{-0.5em}\uncover<2-4>{ % this diagram is visible in slides 2-4.
  \begin{center}
    \begin{tikzpicture}[semithick,
      % The "level X" styles below can be used to uncover graphs or
      % parts thereof across slides.
      level 2/.style={onslide=<-2>{transparent}},
      level 3/.style={onslide=<-3>{transparent}},
      ampersand replacement=\&, every edge/.append style={->}, >=latex]
      \Large % <-- determines scale of diagram. try \LARGE, \Huge, \small...


      % Matrix for arranging graph naodes.  You can set the overall
      % spacing through "row sep" and "column sep" or add and remove
      % horizontal or vertical space in brackets after \& and \\.
      \matrix[graph, column sep=1em] (g1) %<-- general column spacing
      {
        \ccons[minimum width=1em]{l1}{l_1} \&
        \ccons[minimum width=1em]{l2}{l_2} \&[-.5em] % <-- remove space
        \ccons[minimum width=1em]{l3}{l_3} \\
      };

      % Selector edges.
      \path[->]
      (l1-cdr) edge (l2)
      (l2-cdr) edge (l3);

      % Variable egdes.
      \vlabel{left}{l1}{x}

      % This second graph won't be shown until slide 3.
      \begin{scope}[yshift=-4em, level 2]
        \matrix[graph] (g2) %
        {
          \acons{x}{\{x\}} \& \\
          \acons{xt1}{\{x, t_1\}} \&
          \scons{e}{\emptyset}\\[.5em] % <-- extra space
          \acons{y}{\{y\}} \& \acons{t}{\{t\}}\\
        };

        % Selector edges.
        \path[->] % Normal edges.
        (x-cdr) edge (e.north west)
        (xt1-cdr) edge (e)
        (y-cdr) edge (t);
        % A loop.  Not visible until slide 4.
        \draw[->, level 3] (e-cdr) -| ++(1em, 1em) -| (e.north);

        % Variable egdes.
        \vlabel{left}{x}{x}
        \vlabel{yshift=1ex,left}{xt1}{x}
        \vlabel{yshift=-1ex,left}{xt1}{t_1}
        \vlabel{left}{y}{y}
        \vlabel{right}{t}{t}
      \end{scope}
    \end{tikzpicture}
  \end{center}}
  The diagram above won't show up until slide 2.
\end{frame}
\fi



%\begin{frame}[fragile]{Some citations and maths}
%  The \emph{Probability Monad} is a variant of the @List@
%  monad.\footnote{See e.g.\ \cite{RamseyP2002popl,Gibbons2012utp}}
%
%  \begin{lstlisting}
%  type Dist[+A] = List[(A, Double)]
%  final case class Rand[+A](dist: Dist[A]) {
%    // Monadic "bind"
%    def flatMap[B](f: A => Rand[B]): Rand[B] = Rand(
%      for ((v, p) <- dist; (w, q) <- f(v).dist)
%      yield (w, q * p))
%    ...
%  }
%  \end{lstlisting}
%  Computations are sequenced using the \emph{chain rule}:
%  \[
%  \Pr\{ f(X) = y \} = \sum_{x} \Pr\{ f(X) = y \,|\, X = x \} \Pr\{ X =
%  x \}
%  \]
%\end{frame}

\begin{frame}{Thank you!}
  \begin{center}
    \Huge Questions?
  \end{center}
\end{frame}

%%%  Backup slides  %%%

%\appendix
%\newcounter{finalframe}
%\setcounter{finalframe}{\value{framenumber}}
%
%\begin{frame}[noframenumbering]
%  \begin{center}
%    \emph{\LARGE Additional slides}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{The \texttt{grassModel} in Odds}
%  \setcounter{framenumber}{\value{finalframe}}%
%  \begin{lstlisting}
%  trait CodeExample extends Stuff {
%    def grassModel: Rand[Boolean] = {
%      val rain       = flip(0.3)
%      val sprinkler  = flip(0.5)
%      val grassIsWet =
%        flip(0.9) && rain      ||
%        flip(0.8) && sprinkler ||
%        flip(0.1)
%      if (grassIsWet) rain else never
%    }
%  }
%  \end{lstlisting}
%\end{frame}
%
%\begin{frame}[noframenumbering]{Quotes and graphics}
%  The Monty Hall problem:
%  \begin{quote}
%    Suppose you're on a game show, and you're given the choice of
%    three doors: Behind one door is a car; behind the others,
%    goats. You pick a door, say No. 1, and the host, who knows what's
%    behind the doors, opens another door, say No. 3, which has a
%    goat. He then says to you, "Do you want to pick door No. 2?" Is it
%    to your advantage to switch your choice?
%
%    \hfill{\em \cite{vosSavant1990monty}}
%  \end{quote}
%  \begin{center}
%    \includegraphics[height=2cm]{img/monty/Monty_open_door}
%  \end{center}
%\end{frame}


%%% Bibliography

%\bibliography{monty,biblio}
%\bibliographystyle{apalike}

\end{document}


